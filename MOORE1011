//Design Code

module moore1011(
input clk,rst,sequence_in,
output reg out);


parameter s0 = 3'b000,
              s1 = 3'b001,
              s2 = 3'b010,
              s3 = 3'b011,
              s4 = 3'b100;

 reg [2:0] current_state,next_state;

always@(posedge clk  or posedge rst)
begin
if(rst)
current_state<=s0;
else
current_state<=next_state;
end

always@(*)
begin
case(current_state)
s0: next_state= sequence_in ? s1:s0;
s1: next_state= sequence_in ? s1:s2;
s2: next_state= sequence_in ? s3:s0;
s3: next_state= sequence_in ? s4:s2;
s4: next_state= sequence_in ? s1:s2;
default: next_state = s0;
endcase
end


always@(*)
begin
case(current_state)
s4: out=1'b1;
default :out=1'b0;
endcase
end

endmodule




//Testbench

module moore1011_tb();
reg clk,rst,sequence_in;
wire out;


moore1011 dut(.clk(clk),.rst(rst),.sequence_in(sequence_in),.out(out));

 always #5 clk = ~clk;

initial
begin
$monitor("Time=%0t | sequence_in=%b | out=%b | State=%0d", $time, sequence_in, out, dut.current_state);


clk = 0; rst = 1; sequence_in = 0;
        #10 rst = 0;

#10;sequence_in=1;
#10;sequence_in=0;
#10;sequence_in=1;
#10;sequence_in=1;
#10;sequence_in=0;
#10;sequence_in=1;
#10;sequence_in=1;
#10 $finish;

end
endmodule


